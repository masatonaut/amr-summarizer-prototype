<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AMR Graph Overlap Visualizer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #2c3e50, #3498db);
        color: white;
        padding: 30px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
        opacity: 0.5;
      }

      .header h1 {
        font-size: 2.5em;
        font-weight: 300;
        margin-bottom: 10px;
        position: relative;
        z-index: 1;
      }

      .header p {
        font-size: 1.1em;
        opacity: 0.9;
        position: relative;
        z-index: 1;
      }

      .controls {
        padding: 30px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
      }

      .file-input-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .file-input-container {
        position: relative;
      }

      .file-input-label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: #2c3e50;
        font-size: 0.9em;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .file-input {
        width: 100%;
        padding: 12px 16px;
        border: 2px dashed #cbd5e0;
        border-radius: 12px;
        background: white;
        transition: all 0.3s ease;
        cursor: pointer;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: #718096;
        font-size: 0.9em;
      }

      .file-input:hover {
        border-color: #3498db;
        background: #f7fafc;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
      }

      .file-input.dragover {
        border-color: #3498db;
        background: #ebf8ff;
        color: #3498db;
      }

      .controls button {
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .controls button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
      }

      .controls button:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .comparison-container {
        display: flex;
        min-height: 600px;
      }

      .graph-panel {
        flex: 1;
        padding: 30px;
        border-right: 1px solid #e9ecef;
        position: relative;
      }

      .graph-panel:last-child {
        border-right: none;
      }

      .graph-title {
        font-size: 1.3em;
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 20px;
        text-align: center;
        padding: 10px;
        background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .graph-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 400px;
        background: #f8f9fa;
        border-radius: 15px;
        border: 2px dashed #cbd5e0;
        transition: all 0.3s ease;
      }

      .graph-content.has-content {
        border: 1px solid #e9ecef;
        background: white;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }

      .placeholder {
        text-align: center;
        color: #718096;
        font-size: 1.1em;
      }

      .svg-container {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto;
        padding: 20px;
      }

      .svg-container svg {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .legend {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        z-index: 1000;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .legend h3 {
        font-size: 1.1em;
        margin-bottom: 15px;
        color: #2c3e50;
        font-weight: 600;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        font-size: 0.9em;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 10px;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .overlap {
        background-color: #e74c3c;
      }
      .non-overlap {
        background-color: #95a5a6;
      }

      .status {
        padding: 15px 30px;
        text-align: center;
        font-weight: 500;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
      }

      .status.success {
        background: #d4edda;
        color: #155724;
      }

      .status.error {
        background: #f8d7da;
        color: #721c24;
      }

      .status.processing {
        background: #fff3cd;
        color: #856404;
      }

      @media (max-width: 768px) {
        .comparison-container {
          flex-direction: column;
        }

        .graph-panel {
          border-right: none;
          border-bottom: 1px solid #e9ecef;
        }

        .graph-panel:last-child {
          border-bottom: none;
        }

        .legend {
          position: relative;
          top: auto;
          right: auto;
          margin: 20px;
        }
      }

      /* Animation for loading */
      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .processing {
        animation: pulse 1.5s infinite;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>AMR Graph Overlap Visualizer</h1>
        <p>
          Compare AMR graphs and highlight overlapping structures for annotation
          review
        </p>
      </div>

      <div class="controls">
        <div class="file-input-group">
          <div class="file-input-container">
            <label class="file-input-label"
              >AMR Graph 1 (PENMAN notation)</label
            >
            <div class="file-input" id="amr1Input">
              Drop AMR1 file here or click to select
            </div>
            <input
              type="file"
              id="amr1File"
              accept=".amr,.txt"
              style="display: none"
            />
          </div>

          <div class="file-input-container">
            <label class="file-input-label"
              >AMR Graph 2 (PENMAN notation)</label
            >
            <div class="file-input" id="amr2Input">
              Drop AMR2 file here or click to select
            </div>
            <input
              type="file"
              id="amr2File"
              accept=".amr,.txt"
              style="display: none"
            />
          </div>

          <div class="file-input-container">
            <label class="file-input-label">Alignment JSON (optional)</label>
            <div class="file-input" id="alignmentInput">
              Drop alignment.json here or click to select
            </div>
            <input
              type="file"
              id="alignmentFile"
              accept=".json"
              style="display: none"
            />
          </div>

          <div class="file-input-container">
            <label class="file-input-label"
              >Existing SVG Files (optional)</label
            >
            <div class="file-input" id="svgInput">
              Drop sample1.svg and sample2.svg here if available
            </div>
            <input
              type="file"
              id="svgFiles"
              accept=".svg"
              multiple
              style="display: none"
            />
          </div>
        </div>

        <div
          style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap"
        >
          <button id="compareBtn" disabled>Compare AMR Graphs</button>
          <button
            id="autoLoadBtn"
            style="
              background: linear-gradient(135deg, #27ae60, #229954);
              padding: 15px 30px;
              border: none;
              border-radius: 25px;
              color: white;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
            "
          >
            Auto-Load from Server
          </button>
          <button
            id="debugBtn"
            style="
              background: linear-gradient(135deg, #9b59b6, #8e44ad);
              padding: 15px 30px;
              border: none;
              border-radius: 25px;
              color: white;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
            "
          >
            🔍 Debug SVG
          </button>
          <select
            id="fileSelector"
            style="
              padding: 10px 15px;
              border: 2px solid #cbd5e0;
              border-radius: 8px;
              background: white;
              font-size: 0.9em;
              min-width: 200px;
            "
          >
            <option value="">Select file pair...</option>
          </select>
        </div>
      </div>

      <div class="union-container">
        <div class="graph-title">AMR Union Graph</div>
        <div class="graph-content" id="unionContent">
          <div class="placeholder">
            <p>📊 Upload two AMR graphs to see their union visualization</p>
            <p style="margin-top: 10px; font-size: 0.9em; color: #95a5a6">
              Red: Common elements (intersection) | Blue: AMR1 only | Green:
              AMR2 only
            </p>
          </div>
        </div>
      </div>

      <div class="status" id="status">
        Ready to compare AMR graphs. Please upload both AMR files to begin.
      </div>
    </div>

    <div class="legend">
      <h3>Legend</h3>
      <div class="legend-item">
        <div class="legend-color overlap"></div>
        <span>Overlapping nodes/edges</span>
      </div>
      <div class="legend-item">
        <div class="legend-color non-overlap"></div>
        <span>Non-overlapping elements</span>
      </div>
    </div>

    <script>
      class AMRVisualizer {
        constructor() {
          this.amr1Content = null;
          this.amr2Content = null;
          this.alignmentData = null;
          this.serverFiles = [];
          this.initializeEventListeners();
          this.scanServerFiles();
        }

        initializeEventListeners() {
          // File input handling
          this.setupFileInput("amr1", "amr1Input", "amr1File");
          this.setupFileInput("amr2", "amr2Input", "amr2File");
          this.setupFileInput("alignment", "alignmentInput", "alignmentFile");
          this.setupSVGInput();

          // Buttons
          document
            .getElementById("compareBtn")
            .addEventListener("click", () => {
              this.compareGraphs();
            });

          document
            .getElementById("autoLoadBtn")
            .addEventListener("click", () => {
              this.autoLoadFromServer();
            });

          document
            .getElementById("refreshBtn")
            .addEventListener("click", () => {
              this.refreshFiles();
            });

          document.getElementById("debugBtn").addEventListener("click", () => {
            this.debugSVGFiles();
          });

          document
            .getElementById("fileSelector")
            .addEventListener("change", (e) => {
              this.loadSelectedFiles(e.target.value);
            });
        }

        async scanServerFiles() {
          try {
            // Based on your directory structure: /src/amrsummarizer/
            const possibleFiles = [
              "./sample_amrs/sample1.amr",
              "./sample_amrs/sample2.amr",
              "./sample_amrs/sample3.amr",
              "./sample_amrs/sample.amr",
              "./sample1.svg",
              "./sample2.svg",
              "./sample3.svg",
              "./alignment.json",
            ];

            const availableFiles = [];

            // Test each file with proper error handling
            for (const file of possibleFiles) {
              try {
                const response = await fetch(file, { method: "HEAD" });
                if (response.ok || response.status === 200) {
                  availableFiles.push(file);
                  console.log(`✓ Found: ${file}`);
                }
              } catch (e) {
                console.log(`✗ Not found: ${file}`);
              }
            }

            this.serverFiles = availableFiles;
            this.populateFileSelector();

            if (availableFiles.length > 0) {
              this.updateStatus(
                `Found ${
                  availableFiles.length
                } files on server: ${availableFiles
                  .map((f) => f.replace("./", ""))
                  .join(", ")}`,
                "success"
              );
            } else {
              this.updateStatus(
                "No files found on server. Make sure to serve this HTML from the /src/amrsummarizer/ directory.",
                "error"
              );
            }
          } catch (error) {
            this.updateStatus(
              "Server file scanning error. Make sure to serve this HTML via HTTP server.",
              "error"
            );
            console.error("Scan error:", error);
          }
        }

        populateFileSelector() {
          const selector = document.getElementById("fileSelector");
          selector.innerHTML = '<option value="">Select file pair...</option>';

          // Group files by sample number
          const samples = {};
          this.serverFiles.forEach((file) => {
            const match = file.match(/sample(\d+|\.)/);
            if (match) {
              let num = match[1];
              if (num === ".") num = ""; // For sample.amr
              if (!samples[num]) samples[num] = {};

              if (file.includes(".amr")) samples[num].amr = file;
              if (file.includes(".svg")) samples[num].svg = file;
            }
          });

          // Add alignment.json check
          const hasAlignment = this.serverFiles.some((f) =>
            f.includes("alignment.json")
          );

          Object.keys(samples).forEach((num) => {
            const option = document.createElement("option");
            option.value = num;
            const displayNum = num === "" ? "" : num;
            option.textContent = `Sample${
              displayNum ? " " + displayNum : ""
            } (${samples[num].amr ? "AMR" : ""}${
              samples[num].svg ? " + SVG" : ""
            })`;
            selector.appendChild(option);
          });

          if (hasAlignment) {
            const alignmentInfo = document.createElement("small");
            alignmentInfo.style.display = "block";
            alignmentInfo.style.marginTop = "5px";
            alignmentInfo.style.color = "#28a745";
            alignmentInfo.textContent = "✓ alignment.json detected";
            selector.parentNode.appendChild(alignmentInfo);
          }

          // Auto-select if we have sample1 and sample2
          if (samples["1"] && samples["2"]) {
            const autoOption = document.createElement("option");
            autoOption.value = "auto";
            autoOption.textContent = "🔄 Auto-load Sample 1 & 2";
            autoOption.selected = true;
            selector.appendChild(autoOption);
          }
        }

        async loadSelectedFiles(sampleNum) {
          if (!sampleNum) return;

          try {
            this.updateStatus("Loading files from server...", "processing");

            if (sampleNum === "auto") {
              // Auto-load sample1 and sample2
              await this.loadSamplePair("1", "2");
              return;
            }

            // Add cache-busting timestamp
            const timestamp = new Date().getTime();

            // Try to load AMR files
            const amrFile =
              sampleNum === ""
                ? "./sample_amrs/sample.amr"
                : `./sample_amrs/sample${sampleNum}.amr`;
            if (this.serverFiles.includes(amrFile)) {
              const response = await fetch(`${amrFile}?t=${timestamp}`);
              const content = await response.text();

              console.log(`Loaded AMR${sampleNum}:`, content.substring(0, 100));

              if (sampleNum === "1" || sampleNum === "") {
                this.amr1Content = content;
                document.getElementById("amr1Input").innerHTML = `✓ ${amrFile
                  .split("/")
                  .pop()} (from server)`;
                document.getElementById("amr1Input").style.background =
                  "#d4edda";
                document.getElementById("amr1Input").style.color = "#155724";
              } else if (sampleNum === "2") {
                this.amr2Content = content;
                document.getElementById("amr2Input").innerHTML = `✓ ${amrFile
                  .split("/")
                  .pop()} (from server)`;
                document.getElementById("amr2Input").style.background =
                  "#d4edda";
                document.getElementById("amr2Input").style.color = "#155724";
              }
            }

            // Try to load SVG files with cache busting
            const svgFile =
              sampleNum === "" ? "./sample.svg" : `./sample${sampleNum}.svg`;
            if (this.serverFiles.includes(svgFile)) {
              console.log(`Attempting to load SVG: ${svgFile}`);
              const response = await fetch(`${svgFile}?t=${timestamp}`);

              if (!response.ok) {
                throw new Error(
                  `HTTP ${response.status}: ${response.statusText}`
                );
              }

              const svgContent = await response.text();
              console.log(`SVG${sampleNum} loaded, length:`, svgContent.length);
              console.log(
                `SVG${sampleNum} starts with:`,
                svgContent.substring(0, 100)
              );

              if (sampleNum === "1" || sampleNum === "") {
                this.displayGraph(svgContent, "graph1Content");
              } else if (sampleNum === "2") {
                this.displayGraph(svgContent, "graph2Content");
              }
            } else {
              console.log(`SVG file not found in serverFiles: ${svgFile}`);
              console.log("Available files:", this.serverFiles);
            }

            // Try to load alignment.json with cache busting
            if (
              this.serverFiles.some((f) => f.includes("alignment.json")) &&
              !this.alignmentData
            ) {
              const response = await fetch(`./alignment.json?t=${timestamp}`);
              this.alignmentData = await response.json();
              console.log("Alignment data loaded:", this.alignmentData);
              document.getElementById("alignmentInput").innerHTML =
                "✓ alignment.json (from server)";
              document.getElementById("alignmentInput").style.background =
                "#d4edda";
              document.getElementById("alignmentInput").style.color = "#155724";
            }

            this.updateCompareButton();
            this.updateStatus(
              "Files loaded from server successfully!",
              "success"
            );
          } catch (error) {
            this.updateStatus(`Error loading files: ${error.message}`, "error");
            console.error("Load error:", error);
          }
        }

        async loadSamplePair(sample1Num, sample2Num) {
          const timestamp = new Date().getTime();

          // Load sample1
          await this.loadSelectedFiles(sample1Num);

          // Load sample2 with cache busting
          const amr2File = `./sample_amrs/sample${sample2Num}.amr`;
          if (this.serverFiles.includes(amr2File)) {
            const response = await fetch(`${amr2File}?t=${timestamp}`);
            const content = await response.text();
            this.amr2Content = content;
            document.getElementById(
              "amr2Input"
            ).innerHTML = `✓ sample${sample2Num}.amr (from server)`;
            document.getElementById("amr2Input").style.background = "#d4edda";
            document.getElementById("amr2Input").style.color = "#155724";
          }

          const svg2File = `./sample${sample2Num}.svg`;
          if (this.serverFiles.includes(svg2File)) {
            const response = await fetch(`${svg2File}?t=${timestamp}`);
            const svgContent = await response.text();
            this.displayGraph(svgContent, "graph2Content");
          }
        }

        async autoLoadFromServer() {
          try {
            this.updateStatus("Auto-loading available files...", "processing");

            // Load sample1 and sample2 files automatically
            await this.loadSamplePair("1", "2");

            // If we have both SVG files, display them directly
            if (
              this.serverFiles.includes("./sample1.svg") &&
              this.serverFiles.includes("./sample2.svg")
            ) {
              this.updateStatus(
                "SVG files loaded directly from server! Ready for comparison.",
                "success"
              );
            } else if (this.amr1Content && this.amr2Content) {
              // If we have AMR files, enable comparison
              this.updateStatus(
                "AMR files loaded - ready to compare!",
                "success"
              );
            } else {
              this.updateStatus(
                "Some files could not be loaded. Please check that sample1 and sample2 files exist.",
                "error"
              );
            }
          } catch (error) {
            this.updateStatus(
              `Auto-load error: ${error.message}. Make sure you are serving this page via HTTP server.`,
              "error"
            );
            console.error("Auto-load error:", error);
          }
        }

        async refreshFiles() {
          try {
            this.updateStatus("Refreshing files from server...", "processing");

            // Clear current data
            this.amr1Content = null;
            this.amr2Content = null;
            this.alignmentData = null;

            // Reset UI
            document.getElementById("amr1Input").innerHTML =
              "Drop AMR1 file here or click to select";
            document.getElementById("amr1Input").style.background = "";
            document.getElementById("amr1Input").style.color = "";

            document.getElementById("amr2Input").innerHTML =
              "Drop AMR2 file here or click to select";
            document.getElementById("amr2Input").style.background = "";
            document.getElementById("amr2Input").style.color = "";

            document.getElementById("alignmentInput").innerHTML =
              "Drop alignment.json here or click to select";
            document.getElementById("alignmentInput").style.background = "";
            document.getElementById("alignmentInput").style.color = "";

            // Clear graphs
            document.getElementById("graph1Content").innerHTML =
              '<div class="placeholder"><p>📊 Upload your first AMR graph to see the visualization</p></div>';
            document
              .getElementById("graph1Content")
              .classList.remove("has-content");

            document.getElementById("graph2Content").innerHTML =
              '<div class="placeholder"><p>📊 Upload your second AMR graph to see the visualization</p></div>';
            document
              .getElementById("graph2Content")
              .classList.remove("has-content");

            // Re-scan server files
            await this.scanServerFiles();

            // Auto-load if files are available
            if (this.serverFiles.length > 0) {
              await this.autoLoadFromServer();
            }
          } catch (error) {
            this.updateStatus(
              `Error refreshing files: ${error.message}`,
              "error"
            );
          }
        }

        async debugSVGFiles() {
          console.log("=== SVG DEBUG START ===");
          console.log("Server files:", this.serverFiles);

          const svgFiles = ["./sample1.svg", "./sample2.svg"];

          for (const svgFile of svgFiles) {
            try {
              console.log(`\n--- Debugging ${svgFile} ---`);
              const response = await fetch(
                `${svgFile}?t=${new Date().getTime()}`
              );
              console.log("Response status:", response.status);
              console.log(
                "Response headers:",
                Object.fromEntries(response.headers.entries())
              );

              if (response.ok) {
                const content = await response.text();
                console.log("File size:", content.length);
                console.log(
                  "Content type check:",
                  content.includes("<svg") ? "Valid SVG" : "Invalid SVG"
                );
                console.log("First 300 chars:", content.substring(0, 300));
                console.log(
                  "Last 100 chars:",
                  content.substring(content.length - 100)
                );

                // Test display
                const testContainer = svgFile.includes("1")
                  ? "graph1Content"
                  : "graph2Content";
                this.displayGraph(content, testContainer);
              } else {
                console.log(
                  "Failed to load file:",
                  response.status,
                  response.statusText
                );
              }
            } catch (error) {
              console.error(`Error loading ${svgFile}:`, error);
            }
          }

          console.log("=== SVG DEBUG END ===");
          this.updateStatus(
            "Debug complete - check browser console for details",
            "success"
          );
        }

        setupSVGInput() {
          const inputDiv = document.getElementById("svgInput");
          const fileInput = document.getElementById("svgFiles");

          inputDiv.addEventListener("click", () => fileInput.click());
          inputDiv.addEventListener("dragover", (e) => {
            e.preventDefault();
            inputDiv.classList.add("dragover");
          });
          inputDiv.addEventListener("dragleave", () => {
            inputDiv.classList.remove("dragover");
          });
          inputDiv.addEventListener("drop", (e) => {
            e.preventDefault();
            inputDiv.classList.remove("dragover");
            const files = Array.from(e.dataTransfer.files);
            this.handleSVGFiles(files, inputDiv);
          });

          fileInput.addEventListener("change", (e) => {
            if (e.target.files.length > 0) {
              this.handleSVGFiles(Array.from(e.target.files), inputDiv);
            }
          });
        }

        async handleSVGFiles(files, inputDiv) {
          try {
            for (const file of files) {
              const content = await this.readFile(file);
              if (file.name.includes("sample1") || file.name.includes("1")) {
                this.displayGraph(content, "graph1Content");
              } else if (
                file.name.includes("sample2") ||
                file.name.includes("2")
              ) {
                this.displayGraph(content, "graph2Content");
              }
            }

            inputDiv.innerHTML = `✓ ${files.length} SVG file(s) loaded`;
            inputDiv.style.background = "#d4edda";
            inputDiv.style.color = "#155724";

            this.updateStatus("SVG files loaded successfully!", "success");
          } catch (error) {
            inputDiv.innerHTML = `❌ Error loading SVG files`;
            inputDiv.style.background = "#f8d7da";
            inputDiv.style.color = "#721c24";
            this.updateStatus(
              `Error loading SVG files: ${error.message}`,
              "error"
            );
          }
        }

        setupFileInput(type, inputId, fileId) {
          const inputDiv = document.getElementById(inputId);
          const fileInput = document.getElementById(fileId);

          inputDiv.addEventListener("click", () => fileInput.click());
          inputDiv.addEventListener("dragover", (e) => {
            e.preventDefault();
            inputDiv.classList.add("dragover");
          });
          inputDiv.addEventListener("dragleave", () => {
            inputDiv.classList.remove("dragover");
          });
          inputDiv.addEventListener("drop", (e) => {
            e.preventDefault();
            inputDiv.classList.remove("dragover");
            const files = e.dataTransfer.files;
            if (files.length > 0) {
              this.handleFile(files[0], type, inputDiv);
            }
          });

          fileInput.addEventListener("change", (e) => {
            if (e.target.files.length > 0) {
              this.handleFile(e.target.files[0], type, inputDiv);
            }
          });
        }

        async handleFile(file, type, inputDiv) {
          try {
            const content = await this.readFile(file);

            if (type === "amr1") {
              this.amr1Content = content;
              inputDiv.innerHTML = `✓ ${file.name}`;
              inputDiv.style.background = "#d4edda";
              inputDiv.style.color = "#155724";
            } else if (type === "amr2") {
              this.amr2Content = content;
              inputDiv.innerHTML = `✓ ${file.name}`;
              inputDiv.style.background = "#d4edda";
              inputDiv.style.color = "#155724";
            } else if (type === "alignment") {
              this.alignmentData = JSON.parse(content);
              inputDiv.innerHTML = `✓ ${file.name}`;
              inputDiv.style.background = "#d4edda";
              inputDiv.style.color = "#155724";
            }

            this.updateCompareButton();
          } catch (error) {
            inputDiv.innerHTML = `❌ Error reading ${file.name}`;
            inputDiv.style.background = "#f8d7da";
            inputDiv.style.color = "#721c24";
            this.updateStatus(
              `Error reading ${file.name}: ${error.message}`,
              "error"
            );
          }
        }

        readFile(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error("Failed to read file"));
            reader.readAsText(file);
          });
        }

        updateCompareButton() {
          const button = document.getElementById("compareBtn");
          if (this.amr1Content && this.amr2Content) {
            button.disabled = false;
            this.updateStatus(
              "Ready to compare! Click the compare button.",
              "success"
            );
          } else {
            button.disabled = true;
          }
        }

        updateStatus(message, type = "") {
          const statusDiv = document.getElementById("status");
          statusDiv.textContent = message;
          statusDiv.className = `status ${type}`;
        }

        async compareGraphs() {
          this.updateStatus("Processing AMR graphs...", "processing");

          try {
            // If we have existing SVG files, load them directly
            if (this.hasSVGFiles()) {
              await this.loadExistingSVGs();
            } else {
              // Parse AMR graphs using existing pipeline
              const amr1 = this.parseAMR(this.amr1Content);
              const amr2 = this.parseAMR(this.amr2Content);

              // Generate alignment if not provided
              let alignment = this.alignmentData;
              if (!alignment) {
                alignment = this.generateAlignment(amr1, amr2);
              }

              // Generate visualizations
              const svg1 = this.generateSVG(amr1, alignment, "graph1");
              const svg2 = this.generateSVG(amr2, alignment, "graph2");

              // Display results
              this.displayGraph(svg1, "graph1Content");
              this.displayGraph(svg2, "graph2Content");
            }

            this.updateStatus(
              "Comparison complete! Red elements show overlapping structures.",
              "success"
            );
            this.showExportOptions();
          } catch (error) {
            this.updateStatus(
              `Error during comparison: ${error.message}`,
              "error"
            );
          }
        }

        hasSVGFiles() {
          // Check if we can detect existing SVG files in the expected locations
          return false; // This would be implemented based on your file structure
        }

        async loadExistingSVGs() {
          // Load sample1.svg and sample2.svg if they exist
          // This is a placeholder for integration with your existing pipeline
          console.log("Loading existing SVG files...");
        }

        showExportOptions() {
          // Add export functionality after comparison
          const exportDiv = document.createElement("div");
          exportDiv.innerHTML = `
                    <div style="text-align: center; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <button onclick="this.exportResults()" style="margin: 5px; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Export Results
                        </button>
                        <button onclick="this.saveAlignment()" style="margin: 5px; padding: 10px 20px; background: #17a2b8; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Save Alignment
                        </button>
                    </div>
                `;

          const statusDiv = document.getElementById("status");
          statusDiv.parentNode.insertBefore(exportDiv, statusDiv);
        }

        parseAMR(content) {
          // Simple AMR parser - in a real implementation, you'd use a proper PENMAN parser
          const lines = content
            .split("\n")
            .filter((line) => line.trim() && !line.startsWith("#"));
          const nodes = [];
          const edges = [];

          lines.forEach((line) => {
            const trimmed = line.trim();
            if (trimmed.includes(":")) {
              // This is a simplified parser - you'd need a proper PENMAN parser
              const parts = trimmed.split(/\s+/);
              if (parts.length >= 3) {
                const source = parts[0].replace(/[()]/g, "");
                const relation = parts[1];
                const target = parts[2].replace(/[()]/g, "");

                if (!nodes.find((n) => n.id === source)) {
                  nodes.push({ id: source, label: source });
                }
                if (!nodes.find((n) => n.id === target)) {
                  nodes.push({ id: target, label: target });
                }

                edges.push({ source, target, relation });
              }
            }
          });

          return { nodes, edges };
        }

        generateAlignment(amr1, amr2) {
          // Simple alignment generation - in practice, you'd use your Smatch++ implementation
          const nodeAlignments = [];
          const edgeAlignments = [];

          // Find matching nodes by label
          amr1.nodes.forEach((node1) => {
            const match = amr2.nodes.find(
              (node2) => node2.label === node1.label
            );
            if (match) {
              nodeAlignments.push([node1.id, match.id]);
            }
          });

          // Find matching edges
          amr1.edges.forEach((edge1) => {
            const match = amr2.edges.find(
              (edge2) =>
                edge2.relation === edge1.relation &&
                nodeAlignments.some(
                  ([s1, s2]) => s1 === edge1.source && s2 === edge2.source
                ) &&
                nodeAlignments.some(
                  ([t1, t2]) => t1 === edge1.target && t2 === edge2.target
                )
            );
            if (match) {
              edgeAlignments.push([
                `${edge1.source}-${edge1.relation}-${edge1.target}`,
                `${match.source}-${match.relation}-${match.target}`,
              ]);
            }
          });

          return {
            node_alignments: nodeAlignments,
            edge_alignments: edgeAlignments,
          };
        }

        generateSVG(amr, alignment, graphId) {
          const width = 400;
          const height = 300;
          const centerX = width / 2;
          const centerY = height / 2;
          const radius = 100;

          let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

          // Background
          svg += `<rect width="${width}" height="${height}" fill="#f8f9fa" stroke="#e9ecef" stroke-width="1"/>`;

          // Position nodes in a circle
          const nodePositions = {};
          amr.nodes.forEach((node, i) => {
            const angle = (2 * Math.PI * i) / amr.nodes.length;
            nodePositions[node.id] = {
              x: centerX + radius * Math.cos(angle),
              y: centerY + radius * Math.sin(angle),
            };
          });

          // Draw edges
          amr.edges.forEach((edge) => {
            const sourcePos = nodePositions[edge.source];
            const targetPos = nodePositions[edge.target];

            if (sourcePos && targetPos) {
              const isOverlapping = alignment.edge_alignments.some(
                ([e1, e2]) =>
                  (e1.includes(edge.source) && e1.includes(edge.target)) ||
                  (e2.includes(edge.source) && e2.includes(edge.target))
              );

              const color = isOverlapping ? "#e74c3c" : "#95a5a6";
              const strokeWidth = isOverlapping ? 3 : 1;

              svg += `<line x1="${sourcePos.x}" y1="${sourcePos.y}" x2="${
                targetPos.x
              }" y2="${targetPos.y}" 
                                stroke="${color}" stroke-width="${strokeWidth}" marker-end="url(#arrowhead-${color.replace(
                "#",
                ""
              )})"/>`;

              // Edge label
              const midX = (sourcePos.x + targetPos.x) / 2;
              const midY = (sourcePos.y + targetPos.y) / 2;
              svg += `<text x="${midX}" y="${midY}" fill="${color}" font-size="10" text-anchor="middle" 
                                font-family="Arial" font-weight="bold">${edge.relation}</text>`;
            }
          });

          // Draw nodes
          amr.nodes.forEach((node) => {
            const pos = nodePositions[node.id];
            const isOverlapping = alignment.node_alignments.some(
              ([n1, n2]) => n1 === node.id || n2 === node.id
            );

            const color = isOverlapping ? "#e74c3c" : "#95a5a6";
            const strokeColor = isOverlapping ? "#c0392b" : "#7f8c8d";

            svg += `<circle cx="${pos.x}" cy="${pos.y}" r="20" fill="${color}" 
                            stroke="${strokeColor}" stroke-width="2"/>`;
            svg += `<text x="${pos.x}" y="${
              pos.y + 4
            }" fill="white" font-size="12" 
                            text-anchor="middle" font-family="Arial" font-weight="bold">${
                              node.label
                            }</text>`;
          });

          // Arrow markers
          svg += `<defs>
                    <marker id="arrowhead-e74c3c" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                    </marker>
                    <marker id="arrowhead-95a5a6" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#95a5a6"/>
                    </marker>
                </defs>`;

          svg += "</svg>";
          return svg;
        }

        displayGraph(svg, containerId) {
          const container = document.getElementById(containerId);

          // Debug: Log SVG content
          console.log(`Displaying graph in ${containerId}`);
          console.log("SVG content length:", svg.length);
          console.log("SVG first 200 chars:", svg.substring(0, 200));

          // Check if SVG content is valid
          if (!svg || svg.trim().length === 0) {
            container.innerHTML =
              '<div class="placeholder"><p>❌ Empty SVG content</p></div>';
            return;
          }

          // Check if it's actually SVG
          if (!svg.includes("<svg")) {
            container.innerHTML =
              '<div class="placeholder"><p>❌ Invalid SVG format</p></div>';
            console.error("Invalid SVG content:", svg.substring(0, 100));
            return;
          }

          // Create wrapper with error handling
          const svgWrapper = document.createElement("div");
          svgWrapper.className = "svg-container";
          svgWrapper.innerHTML = svg;

          // Add error handling for SVG rendering
          const svgElement = svgWrapper.querySelector("svg");
          if (svgElement) {
            svgElement.style.maxWidth = "100%";
            svgElement.style.height = "auto";
            svgElement.style.border = "1px solid #ddd";

            // Add viewBox if missing
            if (!svgElement.getAttribute("viewBox")) {
              const width = svgElement.getAttribute("width") || "400";
              const height = svgElement.getAttribute("height") || "300";
              svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);
            }
          } else {
            container.innerHTML =
              '<div class="placeholder"><p>❌ Could not parse SVG element</p></div>';
            return;
          }

          container.innerHTML = "";
          container.appendChild(svgWrapper);
          container.classList.add("has-content");

          console.log(`Successfully displayed SVG in ${containerId}`);
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        new AMRVisualizer();
      });
    </script>
  </body>
</html>
